DXRuby用ウィンドウシステムDXRubyWS アーキテクチャいろいろ

■１．はじめに

クラスとメソッドのリファレンスだけあっても、概念的な部分がよくわからないと思います。この文書ではDXRubyWSで実装されているものの考え方などを書いてみます。


■２．クラスとオブジェクトのツリー

DXRubyWSはコントロール(WSContol)とコンテナ(WSContainer)からなるCompositeパターンのような構造をしています。抽象クラスはありません。
コントロールはSpriteを継承しており、

class WSControl < Sprite

コンテナはコントロールを継承しています。

class WSContainer < WSControl

コントロールはDXRubyWS上でコントロールとして振舞うための基本的な機能一式が実装されています。コンテナはそれに加える形で、配下にコントロールを保持して制御する機能が実装されています。もちろんコンテナはコントロールとして振舞うことができます。
すべてのコントロールはWSControlもしくはWSContainerを継承して作ります。すべてのコントロールはSpriteを継承しているので、その機能が使えますし、基本機能はそれを使って作られています。

DXRubyWSは起動しただけで何もしなくてもWS.desktopとして参照可能なWSDesktopオブジェクトが作成されます。WSDesktopはWSContainerを継承したコンテナで、特殊な実装となっています。
DXRubyWSのすべてのコントロールはWS.desktop配下に存在している必要があります。WS.desktop配下のコンテナの配下のコンテナの配下の・・・というツリー構造でも可で、WS.desktopから辿れることが条件です。


■３．イベント

DXRubyWSのイベントはWS.desktopが発行します。発行タイミングはWS.updateを呼んだときで、まず最初にイベント条件のチェックと発行を行い、その後、配下のコントロールのupdateを呼び出します。
イベントはその動作パターンにより2種類に分けられます。マウスイベントとキーボードイベントです。

■３-1．マウスイベント
マウスイベントはマウスの情報に関する変化をメソッド呼び出しという形で発行します。変化とは、カーソルの移動やボタンの押下、ホイールの回転などです。発行されたイベントはマウスカーソルの位置に存在するコントロールに伝達されます。
マウスイベントはマウスカーソルの位置により送信対象が変わりますので、座標やボタン押下状態の変化を検知した場合、イベント送信先をマウスカーソルの座標とデスクトップ配下のコントロールとの衝突判定(Spriteの機能)で調べます。まず最初にデスクトップ配下のコントロールを判定し、コンテナがヒットしたらその配下を判定し・・・と繰り返し、最終的にオブジェクトツリーの先端に存在するコントロールに対してイベントが送信されます。
マウスイベントはon_mouse_xxxという名前のメソッドを呼ぶことで発行し、クラスツリー最上位のWSControlに実装されたイベントメソッドでシグナルを発行します。メソッドをオーバーライドするときはsuperを呼ぶように心がけてください。
on_mouse_overとon_mouse_outはマウスカーソルが乗っているオブジェクトを識別する必要があるので、on_mouse_moveメソッドの戻り値(selfを返す)を保存して判定します。on_mouse_moveをオーバーライドするときはselfを返すように気をつけてください。

■３-2．キーボードイベント
キーボードイベントはキーボードのキーが押されたり離されたり、文字列が入力されたりしたときに発行されます。キーの押下と文字列入力が別になっているのは制御キーとIMEの動作を考慮したもので、文字列のほうには制御コードは入りません。キーの押下のほうには文字も入ってきますが、こっちはカーソルの移動やBackSpace処理などを行う用途で使うことを想定しており、必要なコードだけ拾って処理してください。
キーボードイベントはマウスカーソルの位置は関係なく、フォーカスを持ったコントロールに対して直接送信されます。
フォーカスはWS.focus=で設定しますが、このタイミングでフォーカスを失ったコントロールのon_leave、フォーカスを得たコントロールのon_enterが呼ばれます。これらもイベントの仲間です。


■４．フォーカス

DXRubyWSのフォーカスはキーボードイベントの送信先です。フォーカスを持つコントロールは、ウィンドウならタイトルバーの色が変わり、テキストボックスならカーソルが点滅するような「アクティブ状態」を表現します。フォーカスを持っていても見た目が変わらない場合もあります。何かしら変えたほうが親切でしょう。
フォーカスを持つコントロールはWSControl#activated?を呼ぶとtrueが返ってきます。システムとしてはアクティブなコントロールは1つとしていますが、標準GUIではウィンドウがアクティブになるのと同時にウィンドウ上のコントロールもアクティブになります。この場合、システムから見たアクティブコントロールはウィンドウだけですが、ウィンドウが配下のコントロールのフォーカスを制御しており、システムから受け取ったフォーカス系イベント(on_enter/on_leave)やキーボードイベント(on_key_push/on_key_release/on_string)を配下のコントロールに伝達します。
コントロールにフォーカスを持たせるにはWSControl#activateを呼びます。このメソッドは親コンテナのWSContainer#set_focusを呼び、フォーカス制御機能のないコンテナはさらに上位のWSContainer#set_focusを呼びます。最終的にフォーカス制御機能がある(WindowFocusモジュールをincludeしている)コンテナか、デスクトップオブジェクトに到達するとそこでフォーカスの設定処理が動き、フォーカスが設定されます。この仕掛けはコントロールがウィンドウ上にあるかデスクトップ上にあるか、はたまたさらに別のフォーカス制御機能付きコンテナの上にあるかを意識せずにフォーカスを設定することができるように考え出されたものです。


■５．シグナル

シグナルはユーザ定義のイベントです。
コントロールのadd_handlerメソッドでシグナルハンドラを登録すると、そのコントロールがシグナルを発行したときに登録されたハンドラのコードが動作します。
単純なマウスイベントやキーボードイベントよりももっと複雑な条件でイベントを発行したいような場合に、条件判定してシグナルを発行するようにします。
シグナルを受けるのは自分自身でもいいですし、他のオブジェクトでも構いません。自分自身で受けるぐらいなら普通にメソッドを呼んだほうが早い気はしますので、基本的には外部のオブジェクトが内部のイベントを受け取るような形で使います。


■６．マウスキャプチャ

DXRubyWSにはマウスキャプチャの機能があります。通常、マウスイベントはマウスカーソルの位置にあるコントロールに送信されますが、コントロールをキャプチャすると解除するまでカーソル位置に関係なくそのコントロールにマウスイベントが送信され続けます。
たとえばコントロールをドラッグする場合、マウスの移動後にコントロール上から離れてしまうとon_mouse_moveは別のコントロールに送信されてしまいますので、マウスのボタンを離すまではマウスキャプチャ状態にしておきます。
ポップアップメニュー(メニュー以外をクリックした場合に消すため)やモーダルダイアログ(ダイアログ以外を操作不可にするため)を実装する場合にも使います。


■７．オートレイアウト

コンテナの機能の一つとしてオートレイアウトがあります。コンテナのlayoutメソッドでDSL風に定義できます。
オートレイアウトはコンテナのサイズが変更されたときなどに動作し、配下のコントロールのサイズ変更可/不可や上下左右のマージンを考慮して位置とサイズを自動的に修正します。
基本的にはサイズ変更可能なウィンドウ内のコントロールを再配置するのに使いますが、位置を指定するのが面倒なときにも有効です。
アラインメントの指定を実装するかどうするかで迷っています。レイアウトを多重で定義すれば現状でもおそらくほとんどの局面で対応可能かと思っていますが、本格的にレイアウトを定義する場合には多少面倒かもしれません。
このあたりの判断はもうちょっとまともなアプリを実装するような状態になってからの課題でしょう。
オートレイアウトで設定するコントロールに対して、newで座標とサイズを指定するのが必須になっているところが残念です。省略できるようにしたいところですが色々と問題があるのでうまいやりかたをひらめいたら実装します。


■８．ここまで

書きかけです。



